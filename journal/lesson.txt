typedef struct a {} a; used in linked list

- Creates a struct tag named struct a
- Creates a type alias a for struct a
a point1;                    // Using the type alias
struct a point2;            // Using the struct tag directly

typedef struct { } a; (One 'a')
typedef struct {} a;
- Creates a type alias a for an anonymous struct
- There is no struct tag name
a point1;                    // Works
struct a point2;           // ERROR - no struct tag exists!

==============================================================
1/ structure 

typedef struct {
    Window window;              // X11 window ID (unique identifier for each window)
    int x, y, width, height;    // Window pos cordinates and dimension
} Client;

Display *display;               // Connection to the X server
Window root;                    // The root window (desktop background)
int screen;                     // Which screen/monitor (in multi-monitor setups)
Client clients[100];            // array to store 100 managed windows
int client_count = 0;           // no of currently managed windows

Display (display)
    Represents the connection to the X server (like opening a socket)
    All X11 operations require this display pointer
    Created with XOpenDisplay(NULL) at startup

Root Window (root)
    The background window that covers the entire screen
    Parent of all top-level windows
    Usually obtained with DefaultRootWindow(display)
    Every monitor has its own root window

Screen (screen)
    In X11, a "screen" can mean a physical monitor or a virtual screen
    screen is typically an index (0 for first screen)

    All monitors are ONE BIG virtual screen using XrandR or Xinerama:
    // Your code today - doesn't change with 1 or 100 monitors!
    display = XOpenDisplay(NULL);
    screen = DefaultScreen(display);  // ALWAYS 0 in modern setups
    root = DefaultRootWindow(display);
    
    // One virtual screen covering ALL monitors
    // Example: Monitor 1 (1920x1080) + Monitor 2 (1920x1080)
    // = One virtual screen of 3840x1080
    int total_width = DisplayWidth(display, screen);   // 3840
    int total_height = DisplayHeight(display, screen); // 1080

┌─────────────────────┬─────────────────────┐
│                     │                     │
│     Monitor 1       │     Monitor 2       │
│     (1920x1080)     │     (1920x1080)     │
│                     │                     │
└─────────────────────┴─────────────────────┘
             ↓
┌───────────────────────────────────────────┐
│        One Virtual Screen                 │
│            3840x1080                      │
│  X:0-1919  │  X:1920-3839                 │
│  Monitor 1 │  Monitor 2                   │
└───────────────────────────────────────────┘

Just write your WM for a single virtual screen. 99% of functionality works perfectly. If you later want advanced multi-monitor features (different wallpapers per monitor, different layouts, etc.), then learn XrandR.

Client Array (clients)
    Static array storing up to 100 windows
    Each entry is a Client struct containing window info
    Simpler than dynamic allocation but limits to 100 windows


==============================================================
2/ Setting the event 

XSelectInput(display, root, 
   SubstructureRedirectMask | SubstructureNotifyMask |
   KeyPressMask | ButtonPressMask | PropertyChangeMask);  

// Grab essential keyboard shortcuts
XGrabKey(display, XKeysymToKeycode(display, XK_Return), 
         Mod1Mask, root, True, GrabModeAsync, GrabModeAsync);
XGrabKey(display, XKeysymToKeycode(display, XK_q), 
         Mod1Mask, root, True, GrabModeAsync, GrabModeAsync);
XGrabKey(display, XKeysymToKeycode(display, XK_c), 
             Mod1Mask|ShiftMask, root, True, GrabModeAsync, GrabModeAsync);

// Set WM_NAME property
XStoreName(display, root, "MyWM");

// Set support for WM_DELETE_WINDOW protocol
Atom wm_delete_window = XInternAtom(display, "WM_DELETE_WINDOW", False);
Atom wm_protocols = XInternAtom(display, "WM_PROTOCOLS", False);

EXPLANATION:
display: The connection to the X server
root: The root window (covers the entire screen)
XSelectInput(): The function that sets up event listening

    SUBSTRUCTUREREDIRECTMASK (MOST IMPORTANT FOR A WM)
It gives the window manager control over:
    Managing child windows of the root window (application windows)
    Redirecting window creation, movement, resizing, etc.
    Without this mask, you cannot be a proper window manager

    SUBSTRUCTURENOTIFYMASK
Allows the window manager to receive notifications about:
    Changes to child windows (creation, destruction, restacking)
    Window property changes in the window hierarchy
    Essential for tracking window state

    KEYPRESSMASK
Enables receiving keyboard events on the root window:
    Global keybindings (like Alt+Tab, Super key)
    Essential for implementing keyboard shortcuts

    BUTTONPRESSMASK
Enables receiving mouse button events:
    Root window clicks (for showing menus, etc.)
    Could be used for mouse-based window operations

    PROPERTYCHANGEMASK
Notifies when window properties change:
    Window titles (WM_NAME, _NET_WM_NAME)
    Window class (WM_CLASS)
    Window hints (WM_HINTS, WM_NORMAL_HINTS)
    Essential for tracking window state changes

// we grab some keys XGrabKey
// Set root name

/ Set support for WM_DELETE_WINDOW protocol
Atom wm_delete_window = XInternAtom(display, "WM_DELETE_WINDOW", False);
Atom wm_protocols = XInternAtom(display, "WM_PROTOCOLS", False);

    Gets the atom (identifier) for "WM_DELETE_WINDOW"
    This is a standard protocol that allows windows to be closed gracefully
    When a window wants to close, it sends this message instead of just being destroyed
    Gets the atom for "WM_PROTOCOLS"
    This is a property that lists which protocols a window supports
    Windows set this property to indicate what protocols they understand
After getting these atoms, a typical WM would:
    Check if a window supports the WM_DELETE_WINDOW protocol
    If it does, the WM will send this message when the user tries to close the window
    The application can then save data or ask for confirmation before closing
    If the window doesn't support it, the WM just destroys the window

// Set WM_DELETE_WINDOW as a supported protocol for a window
XSetWMProtocols(display, window, &wm_delete_window, 1);

// Later, when handling window close:
if (event.type == ClientMessage) {
    if (event.xclient.data.l[0] == wm_delete_window) {
        // Send WM_DELETE_WINDOW message to client
        // instead of forcibly killing it
    }
}

    Without WM_DELETE_WINDOW: Clicking close instantly kills the application
    With WM_DELETE_WINDOW: Application gets notified and can clean up properly
    User experience: Applications can ask "Save before closing?" or clean up resources
    WM to ICCCM-compliant (Inter-Client Communication Conventions Manual), which ensures compatibility with standard X11 applications.


